prepend_path() {
    for arg in "$@"; do
        if [[ ":${PATH}:" != *":${arg}:"* ]]; then
            export PATH="${arg}${PATH:+":$PATH"}"
        fi
    done
}

append_path() {
    for arg in "$@"; do
        if [[ ":${PATH}:" != *":${arg}:"* ]]; then
            export PATH="${PATH:+"$PATH:"}${arg}"
        fi
    done
}

function ecr {
    eval $(aws ecr get-login --no-include-email)
}

function reload {
    #exec zsh -l
    source ~/.zshrc
}

lp_add_ssh_key() {
    local file=$1
    local name=$2
    printf "Private Key: %s\nPublic Key: %s" "$(cat $file)" "$(cat $file.pub)" | lpass add --sync=now --non-interactive --note-type=ssh-key $name
}

# Kind load
kind_load() {
    local DIR=$(pwd)
    while [ ! -z "$DIR" ] && [ ! -f "$DIR/.buildtools.yaml" ]; do
        DIR="${DIR%\/*}"
    done

    if [ -z "${DIR}" ]; then
        echo "No .buildtools.yaml file found"
        return
    fi

    local REGISTRY=$(yq e '.registry.* | .url // .registry' ${DIR}/.buildtools.yaml)
    local CLUSTER=$(basename $(dirname $PWD) | tr '[:upper:]' '[:lower:]')
    local NAME=$(basename $PWD)
    local COMMIT=$(git rev-parse HEAD)

    kind load --name ${CLUSTER} docker-image ${REGISTRY}/${NAME}:${COMMIT}
}

ldeploy() {
    kind_load
    deploy local
}

bup() {
  local result file
  file="${HOME}/.local/share/Brewfile"

  echo "Checking Brewfile"
  result=$(brew bundle cleanup --file ${file})
  if [[ $? != 0 ]]; then
    if [[ $(echo "${result}" | grep -cE 'uninstall (formulae|cask)') -gt 0 ]]; then
      echo "Missing installed dependencies in Brewfile ${file}"
      echo "Update before running again"
      echo "${result}"
      return
    else
      echo "Errors in Brewfile ${file}?"
      echo "Fix them and try again"
      return
    fi
  fi

  echo "Brewfile matches installation, updating packages"
  brew update
  brew upgrade
  for cask in $(brew list --cask); do
    brew info --cask $cask --json=v2 \
    | jq -r "[.casks[].outdated,.casks[].installed,.casks[].version] \
    | @tsv" \
    | read outdated installed current && if [[ "$current" != "$installed" ]]; then
      echo "Upgrading $cask from $installed to $current"
      brew upgrade --cask --greedy $cask
    else
      echo "$cask:$current is latest version"
    fi
  done
}

# Update all GitButler projects to latest remote state
but-pull-all() {
    local force=0
    local timeout_secs=30
    local filter=""
    local projects_file="$HOME/Library/Application Support/com.gitbutler.app/projects.json"
    local but_cmd
    but_cmd=$(command -v but)
    if [[ -z "$but_cmd" ]]; then
        echo "but command not found"
        return 1
    fi

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--force)
                force=1
                shift
                ;;
            -t|--timeout)
                timeout_secs="$2"
                shift 2
                ;;
            *)
                filter="$1"
                shift
                ;;
        esac
    done

    if [[ ! -f "$projects_file" ]]; then
        echo "GitButler projects.json not found"
        return 1
    fi

    local matched=0

    for project_path in $(jq -r '.[].path' "$projects_file"); do
        local name=$(basename "$project_path")

        # Skip if filter provided and doesn't match name or path
        if [[ -n "$filter" ]] && [[ "$name" != *"$filter"* ]] && [[ "$project_path" != *"$filter"* ]]; then
            continue
        fi

        if [[ ! -d "$project_path" ]]; then
            echo "$name: \033[33mpath not found, skipping\033[0m"
            continue
        fi

        if [[ -d "$project_path/.git/gitbutler" ]]; then
            ((matched++))
            # Check status first
            local check_output=$(timeout $timeout_secs "$but_cmd" -C "$project_path" pull --check 2>&1)
            local check_status=$?

            if [[ $check_status -eq 124 ]]; then
                echo "$name: \033[31mtimed out during check\033[0m"
            elif echo "$check_output" | grep -q "Up to date"; then
                echo "$name: \033[32mup to date\033[0m"
            elif echo "$check_output" | grep -q "Setup required"; then
                echo "$name: \033[33mnot initialized, skipping\033[0m"
            elif echo "$check_output" | grep -q "bad object"; then
                # Broken refs detected
                if [[ $force -eq 1 ]]; then
                    echo "$name: \033[33mcleaning broken refs...\033[0m"
                    # Find all broken refs from git branch warnings
                    for ref in $(git -C "$project_path" branch 2>&1 | grep "warning: ignoring broken ref" | sed 's/.*refs\/heads\//refs\/heads\//'); do
                        echo "  removing $ref"
                        git -C "$project_path" update-ref -d "$ref" 2>/dev/null
                    done
                    git -C "$project_path" fetch --prune origin 2>/dev/null
                    # Retry pull
                    timeout $timeout_secs "$but_cmd" -C "$project_path" pull
                    if [[ $? -eq 124 ]]; then
                        echo "\033[31m  timed out after ${timeout_secs}s\033[0m"
                    fi
                    echo
                else
                    echo "$name: \033[31mbroken refs\033[0m (use --force to clean)"
                fi
            else
                # Has changes or errors - run with full output
                echo "$name:"
                timeout $timeout_secs "$but_cmd" -C "$project_path" pull
                if [[ $? -eq 124 ]]; then
                    echo "\033[31m  timed out after ${timeout_secs}s\033[0m"
                fi
                echo
            fi
        fi
    done

    if [[ -n "$filter" ]] && [[ $matched -eq 0 ]]; then
        echo "\033[31mNo projects matching '$filter'\033[0m"
        return 1
    fi
}

# Port forward to RDS via SSM through a k8s node
k8s-rds-tunnel() {
    local local_port=35432
    local cluster=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--port)
                local_port="$2"
                shift 2
                ;;
            *)
                cluster="$1"
                shift
                ;;
        esac
    done

    # Check config file
    if [[ -z "$K8S_RDS_CONFIG" ]]; then
        echo "\033[31mK8S_RDS_CONFIG is not set\033[0m"
        return 1
    fi

    if [[ ! -f "$K8S_RDS_CONFIG" ]]; then
        echo "\033[31mConfig file not found: $K8S_RDS_CONFIG\033[0m"
        return 1
    fi

    # Parse available clusters from config
    local clusters=()
    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        clusters+=("${line%% *}")
    done < "$K8S_RDS_CONFIG"

    if [[ -z "$cluster" ]]; then
        echo "Usage: k8s-rds-tunnel <cluster-name> [--port <local-port>]"
        echo ""
        echo "Available clusters:"
        for c in "${clusters[@]}"; do
            echo "  $c"
        done
        return 1
    fi

    # Look up cluster in config
    local rds_host=""
    local region=""
    local remote_port=""
    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        local fields=(${=line})
        if [[ "${fields[1]}" == "$cluster" ]]; then
            rds_host="${fields[2]}"
            region="${fields[3]}"
            remote_port="${fields[4]:-5432}"
            break
        fi
    done < "$K8S_RDS_CONFIG"

    if [[ -z "$rds_host" ]]; then
        echo "\033[31mUnknown cluster: $cluster\033[0m"
        echo ""
        echo "Available clusters:"
        for c in "${clusters[@]}"; do
            echo "  $c"
        done
        return 1
    fi

    # Get a node instance ID from the cluster
    echo "Getting node from cluster $cluster..."
    local instance_id
    instance_id=$(kubectl --context "$cluster" get nodes -o jsonpath='{.items[0].spec.providerID}' 2>&1)
    if [[ $? -ne 0 ]]; then
        echo "\033[31mFailed to get node from cluster: $instance_id\033[0m"
        return 1
    fi

    # Extract instance ID from provider ID (format: aws:///az/i-xxx)
    instance_id="${instance_id##*/}"

    if [[ -z "$instance_id" ]]; then
        echo "\033[31mNo nodes found in cluster $cluster\033[0m"
        return 1
    fi

    echo "Using node: $instance_id"
    echo "Forwarding localhost:$local_port â†’ $rds_host:$remote_port via $instance_id"
    echo ""

    aws ssm start-session \
        --region "$region" \
        --target "$instance_id" \
        --document-name AWS-StartPortForwardingSessionToRemoteHost \
        --parameters "host=$rds_host,portNumber=$remote_port,localPortNumber=$local_port"
}
